#include "LyonPrimaryGeneratorAction.hh"

#include "G4Event.hh"
#include "G4ParticleGun.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "globals.hh"
#include "Randomize.hh"
#include "TRandom.h"
#include "TF1.h"
#include "TF2.h"
#include "TMath.h"
#include <time.h>  
#include <iostream>

#define RANDOM_GUN
//#define SOLID_ANGLE
#define GAUSSIAN_GUN

LyonPrimaryGeneratorAction::LyonPrimaryGeneratorAction()
{
  G4int n_particle = 1;// on genere une particlue
  particleGun = new G4ParticleGun(n_particle);

  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
  G4String particleName;
  particleGun->SetParticleDefinition(particleTable->FindParticle(particleName="mu+"));
  particleGun->SetParticleEnergy(1.0*GeV); 
}

LyonPrimaryGeneratorAction::~LyonPrimaryGeneratorAction()
{
  delete particleGun;
}

void LyonPrimaryGeneratorAction::SetGaussianParameters(double *pars)
{
  gausMean=pars[0];
  gausSigma=pars[1];
  G4cout << "Gun momentum chosen in Gaussian distribution : \n "
	 << "\t mean = " << gausMean 
	 << "\t sigma = " << gausSigma 
	 << std::endl;
}

void LyonPrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent)
{
#ifdef RANDOM_GUN
  float max=0.4;
  float xo=2*max*G4UniformRand()-max;
  float yo=2*max*G4UniformRand()-max;
  G4ThreeVector pos(xo*m, yo*m,-.700*m);
  particleGun->SetParticlePosition(pos);//par default
#endif
#ifndef RANDOM_GUN
  G4ThreeVector pos(0.0*m, 0.0*m,-0.700*m);
  particleGun->SetParticlePosition(pos);//par default
#endif

#ifdef SOLID_ANGLE
  //distribution uniform in solid angle

  G4double X0 = 2.0*m; 
  G4double a = 0.5*m;   
  G4double b = 0.5*m;   
  G4double R0 = std::sqrt(a*a/4+b*b/4);  
  G4double rndm1, rndm2;  
  G4double px, py, pz, projx, projy; 
  G4double MinTheta, MaxTheta, MinPhi, MaxPhi; 
  G4double Phi;
  
  MinTheta = 0.; 
  MaxTheta = std::atan(R0/X0);   
  MinPhi = 0.; 
  MaxPhi = twopi; 		
  G4double sintheta, sinphi, costheta, cosphi, tantheta; 
  
  
  
  do{
  
  
    rndm1 = G4UniformRand();  
    costheta = std::cos(MinTheta) - rndm1 * (std::cos(MinTheta) - std::cos(MaxTheta));
    sintheta = std::sqrt(1. - costheta*costheta);  
    tantheta = sintheta/costheta;  
    
    rndm2 = G4UniformRand();    
    Phi = MinPhi + (MaxPhi - MinPhi) * rndm2;  
    sinphi = std::sin(Phi); 
    cosphi = std::cos(Phi); 
  
    px = sintheta * cosphi;  
    py = sintheta * sinphi;   
    pz = costheta; 
  
     projx = X0*tantheta*cosphi;  
     projy = X0*tantheta*sinphi;   
   
  
  
  }while(sqrt(projx*projx)>500*cm||sqrt(projy*projy)>500*cm);
  G4ThreeVector v(px,py,pz);
  particleGun->SetParticleMomentumDirection(v);
  particleGun->GeneratePrimaryVertex(anEvent);
  G4cout << "Gun position = " << pos << G4endl;
  G4cout << "Gun momentum = " << v << G4endl;
#endif //SOLID_ANGLE
#ifndef SOLID_ANGLE
#ifdef GAUSSIAN_GUN
  //TF2* func=new TF2("func","TMath::Gaus(x,[1],[2])*TMath::Gaus(y,[3],[4])",-1,1,-1,1);
  //func->SetParameters(1,0,.2,0,.2);
  //G4double px;
  //G4double py;
  //func->GetRandom2(px,py);
  TF1 *func=new TF1("func","gaus",-1,1);
  func->SetParameters(1,gausMean,gausSigma);
  G4double px=func->GetRandom();
  G4double py=func->GetRandom();
  G4double pz=1.0;
  G4ThreeVector v(px,py,pz);
  v/=v.mag();
  //  G4ThreeVector v(0.0,0.0,1.0); // par default
  particleGun->SetParticleMomentumDirection(v);
  particleGun->GeneratePrimaryVertex(anEvent);
  G4cout << "Gun position = " << pos << G4endl;
  G4cout << "Gun momentum = " << v << G4endl;
  delete func;
#endif //GAUSSIAN_GUN
#ifndef GAUSSIAN_GUN
  G4double px;
  G4double py;
  if(G4UniformRand()>0.5)px=G4UniformRand();
  else px=-G4UniformRand();
  if(G4UniformRand()>0.5) py=G4UniformRand();
  else py=-G4UniformRand();
  G4double pz=1.0;
  G4ThreeVector v(px,py,pz);
  v/=v.mag();
  //  G4ThreeVector v(0.0,0.0,1.0); // par default
  particleGun->SetParticleMomentumDirection(v);
  particleGun->GeneratePrimaryVertex(anEvent);
  G4cout << "Gun position = " << pos << G4endl;
  G4cout << "Gun momentum = " << v << G4endl;
#endif //NO GAUSSIAN_GUN
#endif //NO SOLID_ANGLE

}
