// ---------------------------------------------------------
// dywPhysicsList
// Construct/define particles and physics processes
// ---------------------------------------------------------- 
// Author: Liang Zhan, 2006/01/27
// Modified by: Weili Zhong, 2006/03/01
// Replaced G4Cerenkov by dywCerenkov to enable weighted 
// photon tracking. jianglai 09-06-2006
// Better Physics for Muon Induced Neutron, Antony Luk 27-03-2007
// ---------------------------------------------------------- 



#include "LyonPhysicsList.hh"
//#include "dywPhysicsListMessenger.hh"
#include <globals.hh>
//#include "LogG4dyb.hh"
#include <iomanip>
//#include "local_g4compat.hh"

#include <G4ParticleTypes.hh>
#include <G4ParticleDefinition.hh>
#include <G4ParticleWithCuts.hh>
#include <G4ParticleTable.hh>
#include <G4IonTable.hh>

#include <G4Element.hh>
#include <G4Material.hh>
#include <G4MaterialTable.hh>

#include <G4ProcessManager.hh>
#include <G4ProcessVector.hh>

#include <G4StepLimiter.hh>
#include <G4UserSpecialCuts.hh>

#include <G4ios.hh>
#include <G4Tokenizer.hh>

//////////////////////////////////////////////////////////////

LyonPhysicsList::LyonPhysicsList():G4VUserPhysicsList()
{
#if 0
  theCerenkovProcess           = 0;
  theScintillationProcess      = 0;
  theAbsorptionProcess         = 0;
  theRayleighScatteringProcess = 0;
  theBoundaryProcess           = 0;
#endif

  defaultCutValue     = 3000.0*micrometer; 
  //cutForGamma         = defaultCutValue;
  cutForGamma         = 10.0*mm; 
  cutForElectron      = defaultCutValue;
  cutForPositron      = defaultCutValue;
	 
  offString  = NULL ;
  //pMessenger = new dywPhysicsListMessenger(this);
  
  SetVerboseLevel(0);
}

LyonPhysicsList::~LyonPhysicsList()
{
    if( offString != NULL ) delete offString ;
}


void LyonPhysicsList::SetOff( G4String off ){
    offString = new G4String( off ) ;    
}

G4bool LyonPhysicsList::IsOff( G4String group ){

    
    if( offString != NULL ){
        G4Tokenizer tzr( *offString );
        G4String t = tzr() ;
        while( !t.isNull() ){
            if( t == group ){
                //LOGWARN( dyb ) << "dywPhysicsList::IsOff WARNING physics group:" << group << " is OFF " << G4endl ; 
                return TRUE ;
            }   
            t = tzr() ;
        }
    }    
    return FALSE ;
}
    

/////////////////////////////////////////////////////////////

#include <G4BosonConstructor.hh>
#include <G4LeptonConstructor.hh>
#include <G4MesonConstructor.hh>
#include <G4BaryonConstructor.hh>
#include <G4IonConstructor.hh>
#include <G4ShortLivedConstructor.hh>

void LyonPhysicsList::ConstructParticle()
{
  // Construct all particles which you want to use.

  ConstructBosons();
  ConstructLeptons();
  ConstructMesons();
  ConstructBaryons();
  ConstructAllIons();
  ConstructAllShortLiveds();
}

void LyonPhysicsList::ConstructBosons()
{
  // bosons
  G4BosonConstructor pConstructor;
  pConstructor.ConstructParticle();
}

void LyonPhysicsList::ConstructLeptons()
{
  // leptons
  G4LeptonConstructor pConstructor;
  pConstructor.ConstructParticle();
  
}

//Adopted a subset of mesons to avoid segv at the very end 
//of the run (seems to be related with B mesons and hLowEIoni???). 
//Carbon-copied the meson list from the example in 
//advanced/underground/physics. Jianglai 05/08/2006
void LyonPhysicsList::ConstructMesons()
{
  // mesons
//   G4MesonConstructor pConstructor;
//   pConstructor.ConstructParticle();
 //  mesons
  G4PionPlus::PionPlusDefinition();
  G4PionMinus::PionMinusDefinition();
  G4PionZero::PionZeroDefinition();
  G4KaonPlus::KaonPlusDefinition();
  G4KaonMinus::KaonMinusDefinition();
  G4Eta::EtaDefinition();
  G4EtaPrime::EtaPrimeDefinition();
  G4KaonZero::KaonZeroDefinition();
  G4AntiKaonZero::AntiKaonZeroDefinition();
  G4KaonZeroLong::KaonZeroLongDefinition();
  G4KaonZeroShort::KaonZeroShortDefinition();
}

void LyonPhysicsList::ConstructBaryons()
{
  // barions
  G4BaryonConstructor pConstructor;
  pConstructor.ConstructParticle();
}

void LyonPhysicsList::ConstructAllIons()
{
  // Construct ions
  G4IonConstructor pConstructor;
  pConstructor.ConstructParticle();  
}

void LyonPhysicsList::ConstructAllShortLiveds()
{
  // Construct  resonaces and quarks
  G4ShortLivedConstructor pConstructor;
  pConstructor.ConstructParticle();  
}

void LyonPhysicsList::ConstructProcess()
{
  AddTransportation();  // Define transportation process
  AddParameterisation();// Define fast simulation manager process
  if(!IsOff("General"))   ConstructGeneral();   // Define decay process
  if(!IsOff("EM"))        ConstructEM();        // Define electromagnetic process
  if(!IsOff("ElectroNu")) ConstructElectroNu(); // Define electronuclear process
  if(!IsOff("Had"))       ConstructHad();       // Define hadronic process
  if(!IsOff("Ion"))       ConstructIon();       // Define process for ions
//  if(!IsOff("Op"))        ConstructOp();        // Define optical process
}

///////////////////////////////////////////////////////////////////
#include "G4FastSimulationManagerProcess.hh"

void LyonPhysicsList::AddParameterisation()
{
  G4FastSimulationManagerProcess* 
    theFastSimulationManagerProcess = 
      new G4FastSimulationManagerProcess();
  theParticleIterator->reset();
  while( (*theParticleIterator)() ){
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    // both postStep and alongStep action are required if the detector
    // makes use of ghost volumes. If no ghost, the postStep
    // is sufficient (and faster?).
#define dyw_USES_GHOST_VOLUMES 0
#if dyw_USES_GHOST_VOLUMES
    pmanager->AddProcess(theFastSimulationManagerProcess, -1, 1, 1);
#else
    pmanager->AddProcess(theFastSimulationManagerProcess, -1, -1, 1);
#endif
  }
}

#include "G4Decay.hh"
#include "G4RadioactiveDecay.hh"

void LyonPhysicsList::ConstructGeneral()
{
  G4Decay* theDecayProcess = new G4Decay();
  theParticleIterator->reset();
  while( (*theParticleIterator)() )
  {
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    if (theDecayProcess->IsApplicable(*particle)) 
    {
      pmanager->AddDiscreteProcess(theDecayProcess);
      pmanager ->SetProcessOrdering(theDecayProcess, idxPostStep);
      pmanager ->SetProcessOrdering(theDecayProcess, idxAtRest);
    }
  }

  const G4IonTable* theIonTable 
    = G4ParticleTable::GetParticleTable()->GetIonTable();
  G4RadioactiveDecay* theRadioactiveDecay = new G4RadioactiveDecay();
  for (G4int i=0; i<theIonTable->Entries(); i++)
  {
    G4String particleName = theIonTable->GetParticle(i)->GetParticleName();
    if (particleName == "GenericIon")
    {
       G4ProcessManager* pmanager 
	 = theIonTable->GetParticle(i)->GetProcessManager();
       pmanager ->AddProcess(theRadioactiveDecay);
       pmanager ->SetProcessOrdering(theRadioactiveDecay, idxPostStep);
       pmanager ->SetProcessOrdering(theRadioactiveDecay, idxAtRest);
    }
  }
	      
}

////////////////////////////// Standard EM Process

#include "G4eMultipleScattering.hh"
#include "G4MuMultipleScattering.hh"
#include "G4hMultipleScattering.hh"

#include "G4eIonisation.hh"
#include "G4eBremsstrahlung.hh"
#include "G4eplusAnnihilation.hh"

#include "G4MuIonisation.hh"
#include "G4MuBremsstrahlung.hh"
#include "G4MuPairProduction.hh"
#include "G4MuonMinusCaptureAtRest.hh"

/////////////////////////////// Low Energy EM Process

#include "G4LowEnergyRayleigh.hh"
#include "G4LowEnergyPhotoElectric.hh"
#include "G4LowEnergyCompton.hh"  
#include "G4LowEnergyGammaConversion.hh"

#include "G4LowEnergyIonisation.hh"
#include "G4LowEnergyBremsstrahlung.hh"

#include "G4hLowEnergyIonisation.hh"
#include "G4EnergyLossTables.hh"
 
void LyonPhysicsList::ConstructEM()
{
  G4LowEnergyPhotoElectric* lowePhot = new G4LowEnergyPhotoElectric();
  G4LowEnergyIonisation* loweIon  = new G4LowEnergyIonisation();
  G4LowEnergyBremsstrahlung* loweBrem = new G4LowEnergyBremsstrahlung();

  // note LowEIon uses proton as basis for its data-base, therefore
  // cannot specify different LowEnergyIonisation models for different
  // particles, but can change model globally for Ion, Alpha and Proton.
   
  //fluorescence apply specific cut for fluorescence from photons, electrons
  //and bremsstrahlung photons:
  G4double fluorcut = 250*eV;
  lowePhot->SetCutForLowEnSecPhotons(fluorcut);
  loweIon->SetCutForLowEnSecPhotons(fluorcut);
  loweBrem->SetCutForLowEnSecPhotons(fluorcut);
  
  theParticleIterator->reset();
  while((*theParticleIterator)())
  {
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    G4String particleName = particle->GetParticleName();
    if(particleName =="gamma")
    {  
      // gamma    
      pmanager->AddDiscreteProcess(new G4LowEnergyRayleigh());
      pmanager->AddDiscreteProcess(lowePhot);
      pmanager->AddDiscreteProcess(new G4LowEnergyCompton());
      pmanager->AddDiscreteProcess(new G4LowEnergyGammaConversion());
    }
    else if(particleName=="e-")
    { 
      // electron
      // process ordering: AddProcess(name, at rest, along step, post step)
      // -1 = not implemented, then ordering	    
      pmanager->AddProcess(new G4eMultipleScattering(),-1, 1, 1);
      pmanager->AddProcess(loweIon,                   -1, 2, 2);
      pmanager->AddProcess(loweBrem,                  -1, -1, 3);
    }
    else if(particleName=="e+")
    {
      // positron
      pmanager->AddProcess(new G4eMultipleScattering(),-1,1,1);
      pmanager->AddProcess(new G4eIonisation(),       -1,2,2);
      pmanager->AddProcess(new G4eBremsstrahlung(),   -1,-1,3);
      pmanager->AddProcess(new G4eplusAnnihilation(),  0,-1,4);
    }	
    else if(particleName == "mu+" ||particleName == "mu-") 
    {
      // muon
      // LOGINFO(dyb)<<"Construct processes for muon"<<G4endl;
      pmanager->AddProcess(new G4muMultipleScattering(),-1, 1, 1);
      pmanager->AddProcess(new G4MuIonisation(),      -1, 2, 2);
      pmanager->AddProcess(new G4MuBremsstrahlung(),  -1, 3, 3);
      pmanager->AddProcess(new G4MuPairProduction(),  -1, 4, 4);
		  
      if( particleName == "mu-" )
        pmanager->AddProcess(new G4MuonMinusCaptureAtRest(), 0,-1,-1);
      } 
    else if ( !(particle->IsShortLived())&&
              (particle->GetPDGCharge() != 0.0) &&
	      (particle->GetParticleName() != "chargedgeantino"))
    {
      // all other charged particles except geantino
      G4MultipleScattering* aMultipleScattering = new G4hMultipleScattering();
      G4hLowEnergyIonisation* ahadronLowEIon = new G4hLowEnergyIonisation();
      pmanager->AddProcess(aMultipleScattering,-1,1,1);
      pmanager->AddProcess(ahadronLowEIon,-1,2,2);
      //fluorescence switch off for hadrons :
      ahadronLowEIon->SetFluorescence(false);
    }
  }
}


//////////////////////////////ElectroNuclear Prcesses


#include "G4PhotoNuclearProcess.hh"
#include "G4GammaNuclearReaction.hh"
#include "G4GammaParticipants.hh"
#include "G4TheoFSGenerator.hh"
#include "G4QGSModel.hh"
#include "G4QGSMFragmentation.hh"
#include "G4ExcitedStringDecay.hh"
#include "G4GeneratorPrecompoundInterface.hh"
#include "G4PhotoNuclearCrossSection.hh"
#include "G4ElectroNuclearReaction.hh"
#include "G4ElectronNuclearProcess.hh"
#include "G4PositronNuclearProcess.hh"
#include "G4MuNuclearInteraction.hh"


void LyonPhysicsList::ConstructElectroNu()
{
  // gamma
  G4ProcessManager* pmanager = G4Gamma::Gamma()->GetProcessManager();

  G4PhotoNuclearProcess * thePhotoNuclearProcess = new G4PhotoNuclearProcess;
  G4GammaNuclearReaction * theGammaReaction = new G4GammaNuclearReaction;
  G4TheoFSGenerator * theModel = new G4TheoFSGenerator;
  G4QGSModel< G4GammaParticipants > * theStringModel = new G4QGSModel< G4GammaParticipants >;
  G4QGSMFragmentation *theFragmentation;
  G4ExcitedStringDecay * theStringDecay = new G4ExcitedStringDecay(theFragmentation=new G4QGSMFragmentation);
  theStringModel->SetFragmentationModel(theStringDecay);
  G4GeneratorPrecompoundInterface * theCascade = new G4GeneratorPrecompoundInterface;
  theModel->SetTransport(theCascade);
  theModel->SetHighEnergyGenerator(theStringModel);
  theGammaReaction->SetMaxEnergy(3.5*GeV);

  thePhotoNuclearProcess->RegisterMe(theGammaReaction);
  
  theModel->SetMinEnergy(3.0*GeV);
  theModel->SetMaxEnergy(100*TeV);
  
  thePhotoNuclearProcess->RegisterMe(theModel);
  
  pmanager->AddDiscreteProcess(thePhotoNuclearProcess);
 
  // e-
  pmanager = G4Electron::Electron()->GetProcessManager();
     
  G4ElectroNuclearReaction* electroNuclear = new G4ElectroNuclearReaction();
  G4ElectronNuclearProcess* theElectroNuclearProcess = new G4ElectronNuclearProcess();

  theElectroNuclearProcess->RegisterMe(electroNuclear);

  pmanager->AddProcess(theElectroNuclearProcess, -1, -1, 5);
  
  // e+
  pmanager = G4Positron::Positron()->GetProcessManager();

  G4PositronNuclearProcess* thePositronNuclearProcess = new G4PositronNuclearProcess();

  thePositronNuclearProcess->RegisterMe(electroNuclear);

  pmanager->AddProcess(thePositronNuclearProcess, -1, -1, 5); 
  
  // Mu-nuclear reaction
  // mu-  
  pmanager = G4MuonMinus::MuonMinus()->GetProcessManager();

  G4MuNuclearInteraction* munucProc = new G4MuNuclearInteraction();
  
  pmanager->AddDiscreteProcess(munucProc);

 // mu+
  pmanager = G4MuonPlus::MuonPlus()->GetProcessManager();
	
  pmanager->AddDiscreteProcess(munucProc);

}



/////////////////////////////////////// Hadron Processes

// elastic fission and capture process for all hadrons
#include "G4HadronElasticProcess.hh"
#include "G4HadronFissionProcess.hh"
#include "G4HadronCaptureProcess.hh"

// inelastice process for each hadron
#include "G4PionPlusInelasticProcess.hh"
#include "G4PionMinusInelasticProcess.hh"
#include "G4KaonPlusInelasticProcess.hh"
#include "G4KaonZeroSInelasticProcess.hh"
#include "G4KaonZeroLInelasticProcess.hh"
#include "G4KaonMinusInelasticProcess.hh"
#include "G4ProtonInelasticProcess.hh"
#include "G4AntiProtonInelasticProcess.hh"
#include "G4NeutronInelasticProcess.hh"
#include "G4AntiNeutronInelasticProcess.hh"
#include "G4LambdaInelasticProcess.hh"
#include "G4AntiLambdaInelasticProcess.hh"
#include "G4SigmaPlusInelasticProcess.hh"
#include "G4SigmaMinusInelasticProcess.hh"
#include "G4AntiSigmaPlusInelasticProcess.hh"
#include "G4AntiSigmaMinusInelasticProcess.hh"
#include "G4XiZeroInelasticProcess.hh"
#include "G4XiMinusInelasticProcess.hh"
#include "G4AntiXiZeroInelasticProcess.hh"
#include "G4AntiXiMinusInelasticProcess.hh"
#include "G4OmegaMinusInelasticProcess.hh"
#include "G4AntiOmegaMinusInelasticProcess.hh"

// Low-energy models

#include "G4LElastic.hh"   
#include "G4LFission.hh"
#include "G4LCapture.hh"

#include "G4UHadronElasticProcess.hh"
#include "G4HadronElastic.hh"
#include "G4PreCompoundModel.hh"
#include "G4BinaryCascade.hh"
#include "G4CascadeInterface.hh"

#include "G4LEPionPlusInelastic.hh"
#include "G4LEPionMinusInelastic.hh"
#include "G4LEKaonPlusInelastic.hh"
#include "G4LEKaonZeroSInelastic.hh"
#include "G4LEKaonZeroLInelastic.hh"
#include "G4LEKaonMinusInelastic.hh"
#include "G4LEProtonInelastic.hh"
#include "G4LEAntiProtonInelastic.hh"
#include "G4LENeutronInelastic.hh"
#include "G4LEAntiNeutronInelastic.hh"
#include "G4LELambdaInelastic.hh"
#include "G4LEAntiLambdaInelastic.hh"
#include "G4LESigmaPlusInelastic.hh"
#include "G4LESigmaMinusInelastic.hh"
#include "G4LEAntiSigmaPlusInelastic.hh"
#include "G4LEAntiSigmaMinusInelastic.hh"
#include "G4LEXiZeroInelastic.hh"
#include "G4LEXiMinusInelastic.hh"
#include "G4LEAntiXiZeroInelastic.hh"
#include "G4LEAntiXiMinusInelastic.hh"
#include "G4LEOmegaMinusInelastic.hh"
#include "G4LEAntiOmegaMinusInelastic.hh"

// High-energy Models

#include "G4HEPionPlusInelastic.hh"
#include "G4HEPionMinusInelastic.hh"
#include "G4HEKaonPlusInelastic.hh"
#include "G4HEKaonZeroInelastic.hh"
#include "G4HEKaonZeroInelastic.hh"
#include "G4HEKaonMinusInelastic.hh"
#include "G4HEProtonInelastic.hh"
#include "G4HEAntiProtonInelastic.hh"
#include "G4HENeutronInelastic.hh"
#include "G4HEAntiNeutronInelastic.hh"
#include "G4HELambdaInelastic.hh"
#include "G4HEAntiLambdaInelastic.hh"
#include "G4HESigmaPlusInelastic.hh"
#include "G4HESigmaMinusInelastic.hh"
#include "G4HEAntiSigmaPlusInelastic.hh"
#include "G4HEAntiSigmaMinusInelastic.hh"
#include "G4HEXiZeroInelastic.hh"
#include "G4HEXiMinusInelastic.hh"
#include "G4HEAntiXiZeroInelastic.hh"
#include "G4HEAntiXiMinusInelastic.hh"
#include "G4HEOmegaMinusInelastic.hh"
#include "G4HEAntiOmegaMinusInelastic.hh"

// high precision model for neutron < 20MeV

#include "G4NeutronHPElastic.hh"
//#include "myNeutronHPInelastic.hh"
#include "G4NeutronHPInelastic.hh"
#include "G4NeutronHPFission.hh"
#include "G4NeutronHPCapture.hh"
//#include "dywNeutronHPCapture.hh" // modified class from G4NeutronHPCapture 

#include "G4NeutronHPCaptureData.hh"
#include "G4NeutronHPFissionData.hh"
#include "G4NeutronHPElasticData.hh"
#include "G4NeutronHPInelasticData.hh"

// Stopping processes
#include "G4AntiProtonAnnihilationAtRest.hh"
#include "G4AntiNeutronAnnihilationAtRest.hh"
#include "G4PionMinusAbsorptionAtRest.hh"
#include "G4KaonMinusAbsorption.hh"

//Cross-section
#include "G4PiNuclearCrossSection.hh"
#include "G4ProtonInelasticCrossSection.hh"
#include "G4NeutronInelasticCrossSection.hh"
#include <G4Version.hh>

inline void AddDataSet(class G4HadronicProcess*p, class G4VCrossSectionDataSet*d) 
{ 
  p->AddDataSet(d); 
}

void LyonPhysicsList::ConstructHad()
{

  // Hadronic Elastic Process and Model (the same for all hadrons except Neutron)

  G4HadronElasticProcess* theElasticProcess = new G4HadronElasticProcess("LElastic");
  G4LElastic* theElasticModel = new G4LElastic();
  theElasticProcess->RegisterMe(theElasticModel);


  // evaporation logic for thermal nucleons

  G4Evaporation* theEvaporation;
  G4FermiBreakUp* theFermiBreakUp;
  G4StatMF* theMF;
  theEvaporation = new G4Evaporation();
  theFermiBreakUp = new G4FermiBreakUp();
  theMF = new G4StatMF();

  G4ExcitationHandler* theHandler;
  theHandler = new G4ExcitationHandler();
  theHandler->SetEvaporation(theEvaporation);
  theHandler->SetFermiModel(theFermiBreakUp);
  theHandler->SetMultiFragmentation(theMF);
  theHandler->SetMaxAandZForFermiBreakUp(12, 6);
  theHandler->SetMinEForMultiFrag(3.*MeV);

  // pre-equilibrium stage for proton
  G4PreCompoundModel* thePreEquilib;
  thePreEquilib = new G4PreCompoundModel(theHandler);
  thePreEquilib->SetMaxEnergy(70*MeV);

  // pre-equilibrium stage for neutron
  G4PreCompoundModel* thePreEquilib2;
  thePreEquilib2 = new G4PreCompoundModel(theHandler);
  thePreEquilib2->SetMinEnergy(20*MeV);
  thePreEquilib2->SetMaxEnergy(70*MeV);

  // high energy model for proton, neutron, pions and kaons
  G4TheoFSGenerator* theHEModel = new G4TheoFSGenerator();
  G4GeneratorPrecompoundInterface* theCascade2 =
                                    new G4GeneratorPrecompoundInterface();
  theCascade2->SetDeExcitation(thePreEquilib);
  theHEModel->SetTransport(theCascade2);
  G4QGSMFragmentation* frag = new G4QGSMFragmentation();
  G4ExcitedStringDecay* stringDecay = new G4ExcitedStringDecay(frag);
  G4QGSModel<G4QGSParticipants>* stringModel =
                                   new G4QGSModel<G4QGSParticipants>();
  stringModel->SetFragmentationModel(stringDecay);
  theHEModel->SetHighEnergyGenerator(stringModel);
  theHEModel->SetMinEnergy(12*GeV);
  theHEModel->SetMaxEnergy(100*TeV);

  // Low energy parameterized models : use between 9.5 and 25 GeV for pions
  G4double LEPUpperLimit = 25*GeV;
  G4double LEPpnpiLimit = 9.5*GeV;

  // Binary cascade for p, n at low energy
  G4BinaryCascade* theCasc;
  theCasc = new G4BinaryCascade;
  theCasc->SetMinEnergy(65*MeV);
  theCasc->SetMaxEnergy(9.9*GeV);

  // Binary cascade crashes on pi. use Bertini instead
  G4CascadeInterface* bertiniModel = new G4CascadeInterface();
  bertiniModel->SetMinEnergy(0.*GeV);
  bertiniModel->SetMaxEnergy(9.9*GeV);

  G4ProcessManager * pmanager = 0;

  ///////////////////
  //               //
  //  pi+ physics  //
  //               //
  ///////////////////

  pmanager = G4PionPlus::PionPlus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4PionPlusInelasticProcess* pipinelProc = new G4PionPlusInelasticProcess();
  G4PiNuclearCrossSection* pion_XC = new G4PiNuclearCrossSection();
  pipinelProc->AddDataSet(pion_XC);

  pipinelProc->RegisterMe(bertiniModel);

  G4LEPionPlusInelastic* LEPpipModel = new G4LEPionPlusInelastic();
  LEPpipModel->SetMinEnergy(LEPpnpiLimit);
  LEPpipModel->SetMaxEnergy(LEPUpperLimit);

  pipinelProc->RegisterMe(LEPpipModel);
  pipinelProc->RegisterMe(theHEModel);
  
  pmanager->AddDiscreteProcess(pipinelProc);

  ///////////////////
  //               //
  //  pi- physics  //
  //               //
  ///////////////////

  pmanager = G4PionMinus::PionMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4PionMinusInelasticProcess* piminelProc = new G4PionMinusInelasticProcess();

  piminelProc->AddDataSet(pion_XC);

  piminelProc->RegisterMe(bertiniModel);

  G4LEPionMinusInelastic* LEPpimModel = new G4LEPionMinusInelastic();
  LEPpimModel->SetMinEnergy(LEPpnpiLimit);
  LEPpimModel->SetMaxEnergy(LEPUpperLimit);
      
  piminelProc->RegisterMe(LEPpimModel);
  piminelProc->RegisterMe(theHEModel);

  pmanager->AddDiscreteProcess(piminelProc);

  // pi- absorption at rest
  G4PionMinusAbsorptionAtRest* pimAbsorb = new G4PionMinusAbsorptionAtRest();
  pmanager->AddRestProcess(pimAbsorb);

  ///////////////////
  //               //
  //  K+ physics   //
  //               //
  ///////////////////

  pmanager = G4KaonPlus::KaonPlus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);


  // hadron inelastic
  G4KaonPlusInelasticProcess* kpinelProc = new G4KaonPlusInelasticProcess();
  G4LEKaonPlusInelastic* LEPkpModel = new G4LEKaonPlusInelastic();
  LEPkpModel->SetMaxEnergy(LEPUpperLimit);
      
  kpinelProc->RegisterMe(LEPkpModel);
  kpinelProc->RegisterMe(theHEModel);
      
  pmanager->AddDiscreteProcess(kpinelProc);

  ///////////////////
  //               //
  //  K0S physics  //
  //               //
  ///////////////////

  pmanager = G4KaonZeroShort::KaonZeroShort()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4KaonZeroSInelasticProcess* k0SinelProc = new G4KaonZeroSInelasticProcess();
  G4LEKaonZeroSInelastic* LEPk0SModel = new G4LEKaonZeroSInelastic();
  LEPk0SModel->SetMaxEnergy(LEPUpperLimit);

  k0SinelProc->RegisterMe(LEPk0SModel);
  k0SinelProc->RegisterMe(theHEModel);
      
  pmanager->AddDiscreteProcess(k0SinelProc);

  ///////////////////
  //               //
  //  K0L physics  //
  //               //
  ///////////////////

  pmanager = G4KaonZeroLong::KaonZeroLong()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4KaonZeroLInelasticProcess* k0LinelProc = new G4KaonZeroLInelasticProcess();
  G4LEKaonZeroLInelastic* LEPk0LModel = new G4LEKaonZeroLInelastic();
  LEPk0LModel->SetMaxEnergy(LEPUpperLimit);
      
  k0LinelProc->RegisterMe(LEPk0LModel);
  k0LinelProc->RegisterMe(theHEModel);
      
  pmanager->AddDiscreteProcess(k0LinelProc);

  ///////////////////
  //               //
  //  K- physics   //
  //               //
  ///////////////////

  pmanager = G4KaonMinus::KaonMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);
      
  // hadron inelastic
  G4KaonMinusInelasticProcess* kminelProc = new G4KaonMinusInelasticProcess();
  G4LEKaonMinusInelastic* LEPkmModel = new G4LEKaonMinusInelastic();
  LEPkmModel->SetMaxEnergy(LEPUpperLimit);
      
  kminelProc->RegisterMe(LEPkmModel);
  kminelProc->RegisterMe(theHEModel);
      
  pmanager->AddDiscreteProcess(kminelProc);

  // K- absorption at rest
  G4KaonMinusAbsorption* kmAbsorb = new G4KaonMinusAbsorption();
  pmanager->AddRestProcess(kmAbsorb);
  
  ///////////////////
  //               //
  //    Proton     //
  //               //
  ///////////////////

  pmanager = G4Proton::Proton()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4ProtonInelasticProcess* pinelProc = new G4ProtonInelasticProcess();
  G4ProtonInelasticCrossSection* proton_XC = 
                                        new G4ProtonInelasticCrossSection();
  pinelProc->AddDataSet(proton_XC);

  G4LEProtonInelastic* LEPpModel = new G4LEProtonInelastic();
  LEPpModel->SetMinEnergy(LEPpnpiLimit);
  LEPpModel->SetMaxEnergy(LEPUpperLimit);

  pinelProc->RegisterMe(thePreEquilib);
  pinelProc->RegisterMe(theCasc);
  pinelProc->RegisterMe(LEPpModel);
  pinelProc->RegisterMe(theHEModel);

  pmanager->AddDiscreteProcess(pinelProc);

  ///////////////////
  //               //
  //  Anti-Proton  //
  //               //
  ///////////////////

  pmanager = G4AntiProton::AntiProton()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiProtonInelasticProcess* apinelProc = 
	                               new G4AntiProtonInelasticProcess();
  G4LEAntiProtonInelastic* LEPapModel = new G4LEAntiProtonInelastic(); 
  LEPapModel->SetMaxEnergy(LEPUpperLimit);
  apinelProc->RegisterMe(LEPapModel);

  G4HEAntiProtonInelastic* HEPapModel = new G4HEAntiProtonInelastic(); 
  HEPapModel->SetMinEnergy(LEPUpperLimit);
  apinelProc->RegisterMe(HEPapModel);

  pmanager->AddDiscreteProcess(apinelProc);

  // anti-proton annihilation at rest
  G4AntiProtonAnnihilationAtRest* apAnnihil = 
	                             new G4AntiProtonAnnihilationAtRest();
  pmanager->AddRestProcess(apAnnihil);
 
  ///////////////////
  //               //
  //    Neutron    //
  //               //
  ///////////////////

  pmanager = G4Neutron::Neutron()->GetProcessManager();
      
#if 1      
  // inelastic scattering
  G4NeutronInelasticProcess* ninelProc = new G4NeutronInelasticProcess();
  G4NeutronInelasticCrossSection* neutron_XC = 
                                  new G4NeutronInelasticCrossSection();
  ninelProc->AddDataSet(neutron_XC);
  
//#if G4VERSION_NUMBER >= 920  
  G4NeutronHPInelastic* theNeutronHPInelastic = new G4NeutronHPInelastic();
//#else
//  myNeutronHPInelastic* theNeutronHPInelastic = new myNeutronHPInelastic();
//#endif
  theNeutronHPInelastic->SetMaxEnergy(20.*MeV );
  G4NeutronHPInelasticData* theHPInelasticData = new G4NeutronHPInelasticData();

  G4LENeutronInelastic* LEPnModel = new G4LENeutronInelastic();
  LEPnModel->SetMinEnergy(LEPpnpiLimit);
  LEPnModel->SetMaxEnergy(LEPUpperLimit);

  ninelProc->RegisterMe(theNeutronHPInelastic);
  ninelProc->AddDataSet(theHPInelasticData);
  ninelProc->RegisterMe(thePreEquilib2);
  ninelProc->RegisterMe(theCasc);
  ninelProc->RegisterMe(LEPnModel);
  ninelProc->RegisterMe(theHEModel);

  pmanager->AddDiscreteProcess(ninelProc);
#endif

  // capture  
  G4HadronCaptureProcess* theNeutronCaptureProcess = new G4HadronCaptureProcess();
  G4LCapture* theNeutronLCapture = new G4LCapture();
  G4NeutronHPCapture* theNeutronHPCapture = new   G4NeutronHPCapture();
  theNeutronHPCapture->SetMaxEnergy( 20.*MeV );
  theNeutronLCapture->SetMinEnergy( 20.*MeV );
  theNeutronCaptureProcess->RegisterMe( theNeutronHPCapture );
  theNeutronCaptureProcess->RegisterMe( theNeutronLCapture );
  AddDataSet(theNeutronCaptureProcess, new G4NeutronHPCaptureData());
  pmanager->AddDiscreteProcess(theNeutronCaptureProcess);

#if 1
  // elastic scattering

  G4UHadronElasticProcess* theHadronElasticProcess = new G4UHadronElasticProcess("neutronElastic");
  G4HadronElastic* theNeutronElasticModel = new G4HadronElastic();
  G4NeutronHPElastic* theNeutronHPElastic = new G4NeutronHPElastic();
  theNeutronHPElastic->SetMinEnergy(0.*MeV);
  theNeutronHPElastic->SetMaxEnergy(20.*MeV);
  G4NeutronHPElasticData* theHPElasticData = new G4NeutronHPElasticData();
  theNeutronElasticModel->SetMinEnergy(20.*MeV);
  
  theHadronElasticProcess->RegisterMe(theNeutronHPElastic);
  theHadronElasticProcess->AddDataSet(theHPElasticData);
  theHadronElasticProcess->RegisterMe(theNeutronElasticModel);

  pmanager->AddDiscreteProcess(theHadronElasticProcess);
#endif

  // fission process 
  G4HadronFissionProcess* theHadronFissionProcess = new G4HadronFissionProcess();
  G4LFission* theNeutronLFission = new G4LFission();
  G4NeutronHPFission* theNeutronHPFission  = new   G4NeutronHPFission();
  theNeutronHPFission->SetMaxEnergy( 20.*MeV );
  theNeutronLFission->SetMinEnergy( 20.*MeV );
  theHadronFissionProcess->RegisterMe( theNeutronHPFission );
  theHadronFissionProcess->RegisterMe( theNeutronLFission );
  AddDataSet(theHadronFissionProcess, new G4NeutronHPFissionData() );
  pmanager->AddDiscreteProcess(theHadronFissionProcess);

  ///////////////////
  //               //
  // Anti-Neutron  //
  //               //
  ///////////////////

  pmanager = G4AntiNeutron::AntiNeutron()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiNeutronInelasticProcess* aninelProc = 
                                  new G4AntiNeutronInelasticProcess();
  G4LEAntiNeutronInelastic* LEPanModel = new G4LEAntiNeutronInelastic();
  LEPanModel->SetMaxEnergy(LEPUpperLimit); 
  aninelProc->RegisterMe(LEPanModel);
  G4HEAntiNeutronInelastic* HEPanModel = new G4HEAntiNeutronInelastic();
  HEPanModel->SetMinEnergy(LEPUpperLimit);
  aninelProc->RegisterMe(HEPanModel);
  pmanager->AddDiscreteProcess(aninelProc);

  // anti-neutron annihilation at rest
  G4AntiNeutronAnnihilationAtRest* anAnnihil = 
                                 new G4AntiNeutronAnnihilationAtRest();
  pmanager->AddRestProcess(anAnnihil);

  ///////////////////
  //               //
  //    Lambda     //
  //               //
  ///////////////////

  pmanager = G4Lambda::Lambda()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4LambdaInelasticProcess* linelProc = 
                                  new G4LambdaInelasticProcess();
  G4LELambdaInelastic* LEPlModel = new G4LELambdaInelastic();
  LEPlModel->SetMaxEnergy(LEPUpperLimit); 
  linelProc->RegisterMe(LEPlModel);
  G4HELambdaInelastic* HEPlModel = new G4HELambdaInelastic(); 
  HEPlModel->SetMinEnergy(LEPUpperLimit);
  linelProc->RegisterMe(HEPlModel);
  
  pmanager->AddDiscreteProcess(linelProc);

  ///////////////////
  //               //
  //  Anti-Lambda  //
  //               //
  ///////////////////

  pmanager = G4AntiLambda::AntiLambda()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiLambdaInelasticProcess* alinelProc = 
                                  new G4AntiLambdaInelasticProcess();
  G4LEAntiLambdaInelastic* LEPalModel = new G4LEAntiLambdaInelastic();
  LEPalModel->SetMaxEnergy(LEPUpperLimit); 
  alinelProc->RegisterMe(LEPalModel);
  G4HEAntiLambdaInelastic* HEPalModel = new G4HEAntiLambdaInelastic(); 
  HEPalModel->SetMinEnergy(LEPUpperLimit);
  alinelProc->RegisterMe(HEPalModel);

  pmanager->AddDiscreteProcess(alinelProc);

  ///////////////////
  //               //
  //    Sigma+     //
  //               //
  ///////////////////

  pmanager = G4SigmaPlus::SigmaPlus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4SigmaPlusInelasticProcess* spinelProc = new G4SigmaPlusInelasticProcess();
  G4LESigmaPlusInelastic* LEPspModel = new G4LESigmaPlusInelastic();
  LEPspModel->SetMaxEnergy(LEPUpperLimit);
  spinelProc->RegisterMe(LEPspModel);
  G4HESigmaPlusInelastic* HEPspModel = new G4HESigmaPlusInelastic(); 
  HEPspModel->SetMinEnergy(LEPUpperLimit);
  spinelProc->RegisterMe(HEPspModel);
      
  pmanager->AddDiscreteProcess(spinelProc);

  ///////////////////
  //               //
  //    Sigma-     //
  //               //
  ///////////////////

  pmanager = G4SigmaMinus::SigmaMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4SigmaMinusInelasticProcess* sminelProc = 
                                  new G4SigmaMinusInelasticProcess();
  G4LESigmaMinusInelastic* LEPsmModel = new G4LESigmaMinusInelastic(); 
  LEPsmModel->SetMaxEnergy(LEPUpperLimit);
  sminelProc->RegisterMe(LEPsmModel);
  G4HESigmaMinusInelastic* HEPsmModel = new G4HESigmaMinusInelastic(); 
  HEPsmModel->SetMinEnergy(LEPUpperLimit);
  sminelProc->RegisterMe(HEPsmModel);
      
  pmanager->AddDiscreteProcess(sminelProc);

  ///////////////////
  //               //
  //  Anti-Sigma+  //
  //               //
  ///////////////////

  pmanager = G4AntiSigmaPlus::AntiSigmaPlus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiSigmaPlusInelasticProcess* aspinelProc = 
                                  new G4AntiSigmaPlusInelasticProcess();
  G4LEAntiSigmaPlusInelastic* LEPaspModel = 
                                  new G4LEAntiSigmaPlusInelastic(); 
  LEPaspModel->SetMaxEnergy(LEPUpperLimit);
  aspinelProc->RegisterMe(LEPaspModel);
  G4HEAntiSigmaPlusInelastic* HEPaspModel = 
                                  new G4HEAntiSigmaPlusInelastic(); 
  HEPaspModel->SetMinEnergy(LEPUpperLimit);
  aspinelProc->RegisterMe(HEPaspModel);
  pmanager->AddDiscreteProcess(aspinelProc);

  ///////////////////
  //               //
  //  Anti-Sigma-  //
  //               //
  ///////////////////

  pmanager = G4AntiSigmaMinus::AntiSigmaMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);
      
  // hadron inelastic
  G4AntiSigmaMinusInelasticProcess* asminelProc = 
                                  new G4AntiSigmaMinusInelasticProcess();
  G4LEAntiSigmaMinusInelastic* LEPasmModel = 
                                  new G4LEAntiSigmaMinusInelastic(); 
  LEPasmModel->SetMaxEnergy(LEPUpperLimit);
  asminelProc->RegisterMe(LEPasmModel);
  G4HEAntiSigmaMinusInelastic* HEPasmModel = 
                                  new G4HEAntiSigmaMinusInelastic(); 
  HEPasmModel->SetMinEnergy(LEPUpperLimit);
  asminelProc->RegisterMe(HEPasmModel);

  pmanager->AddDiscreteProcess(asminelProc);

  ///////////////////
  //               //
  //      Xi0      //
  //               //
  ///////////////////

  pmanager = G4XiZero::XiZero()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4XiZeroInelasticProcess* x0inelProc = new G4XiZeroInelasticProcess();
  G4LEXiZeroInelastic* LEPx0Model = new G4LEXiZeroInelastic();
  LEPx0Model->SetMaxEnergy(LEPUpperLimit); 
  x0inelProc->RegisterMe(LEPx0Model);
  G4HEXiZeroInelastic* HEPx0Model = new G4HEXiZeroInelastic(); 
  HEPx0Model->SetMinEnergy(LEPUpperLimit);
  x0inelProc->RegisterMe(HEPx0Model);

  pmanager->AddDiscreteProcess(x0inelProc);

  ///////////////////
  //               //
  //      Xi-      //
  //               //
  ///////////////////

  pmanager = G4XiMinus::XiMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4XiMinusInelasticProcess* xminelProc = new G4XiMinusInelasticProcess();
  G4LEXiMinusInelastic* LEPxmModel = new G4LEXiMinusInelastic(); 
  LEPxmModel->SetMaxEnergy(LEPUpperLimit);
  xminelProc->RegisterMe(LEPxmModel);
  G4HEXiMinusInelastic* HEPxmModel = new G4HEXiMinusInelastic();
  HEPxmModel->SetMinEnergy(LEPUpperLimit);
  xminelProc->RegisterMe(HEPxmModel);
      
  pmanager->AddDiscreteProcess(xminelProc);

  ///////////////////
  //               //
  //   Anti-Xi0    //
  //               //
  ///////////////////

  pmanager = G4AntiXiZero::AntiXiZero()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiXiZeroInelasticProcess* ax0inelProc = 
                                new G4AntiXiZeroInelasticProcess();
  G4LEAntiXiZeroInelastic* LEPax0Model = new G4LEAntiXiZeroInelastic();
  LEPax0Model->SetMaxEnergy(LEPUpperLimit); 
  ax0inelProc->RegisterMe(LEPax0Model);
  G4HEAntiXiZeroInelastic* HEPax0Model = new G4HEAntiXiZeroInelastic(); 
  HEPax0Model->SetMinEnergy(LEPUpperLimit);
  ax0inelProc->RegisterMe(HEPax0Model);

  pmanager->AddDiscreteProcess(ax0inelProc);

  ///////////////////
  //               //
  //   Anti-Xi-    //
  //               //
  ///////////////////

  pmanager = G4AntiXiMinus::AntiXiMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiXiMinusInelasticProcess* axminelProc = 
                                  new G4AntiXiMinusInelasticProcess();
  G4LEAntiXiMinusInelastic* LEPaxmModel = new G4LEAntiXiMinusInelastic();
  LEPaxmModel->SetMaxEnergy(LEPUpperLimit);
  axminelProc->RegisterMe(LEPaxmModel);
  G4HEAntiXiMinusInelastic* HEPaxmModel = new G4HEAntiXiMinusInelastic();
  HEPaxmModel->SetMinEnergy(LEPUpperLimit);
  axminelProc->RegisterMe(HEPaxmModel);

  pmanager->AddDiscreteProcess(axminelProc);

  ///////////////////
  //               //
  //    Omega-     //
  //               //
  ///////////////////

  pmanager = G4OmegaMinus::OmegaMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4OmegaMinusInelasticProcess* ominelProc = 
                                      new G4OmegaMinusInelasticProcess();
  G4LEOmegaMinusInelastic* LEPomModel = new G4LEOmegaMinusInelastic();
  LEPomModel->SetMaxEnergy(LEPUpperLimit); 
  ominelProc->RegisterMe(LEPomModel);
  G4HEOmegaMinusInelastic* HEPomModel = new G4HEOmegaMinusInelastic();
  HEPomModel->SetMinEnergy(LEPUpperLimit);
  ominelProc->RegisterMe(HEPomModel);
      
  pmanager->AddDiscreteProcess(ominelProc);

  ///////////////////
  //               //
  //  Anti-Omega-  //
  //               //
  ///////////////////

  pmanager = G4AntiOmegaMinus::AntiOmegaMinus()->GetProcessManager();

  // hadron elastic
  pmanager->AddDiscreteProcess(theElasticProcess);

  // hadron inelastic
  G4AntiOmegaMinusInelasticProcess* aominelProc = 
                                      new G4AntiOmegaMinusInelasticProcess();
  G4LEAntiOmegaMinusInelastic* LEPaomModel = 
                                      new G4LEAntiOmegaMinusInelastic();
  LEPaomModel->SetMaxEnergy(LEPUpperLimit);
  aominelProc->RegisterMe(LEPaomModel);
  G4HEAntiOmegaMinusInelastic* HEPaomModel = 
                                      new G4HEAntiOmegaMinusInelastic(); 
  HEPaomModel->SetMinEnergy(LEPUpperLimit);
  aominelProc->RegisterMe(HEPaomModel);

  pmanager->AddDiscreteProcess(aominelProc);

}

///////////////////////////////////////////////////

#include "G4DeuteronInelasticProcess.hh"
#include "G4LEDeuteronInelastic.hh"

#include "G4TritonInelasticProcess.hh"
#include "G4LETritonInelastic.hh"

#include "G4AlphaInelasticProcess.hh"
#include "G4LEAlphaInelastic.hh"

#include "G4BinaryLightIonReaction.hh"
#include "G4TripathiCrossSection.hh"
#include "G4IonsShenCrossSection.hh"


void LyonPhysicsList::ConstructIon()
{
  G4ProcessManager* pmanager = 0;
  // Elastic Process
  G4HadronElasticProcess* theElasticProcess = new G4HadronElasticProcess();
  G4LElastic* theElasticModel = new G4LElastic();
  theElasticProcess->RegisterMe(theElasticModel);
  
  // Generic Ion
  pmanager = G4GenericIon::GenericIon()->GetProcessManager();
  // add process
  pmanager->AddDiscreteProcess(theElasticProcess);

  // preparing inelastic reactions for light nuclei 
  G4BinaryLightIonReaction* theIonCascade;
  G4BinaryLightIonReaction* theGenIonCascade;

  // binary cascade for light nuclei
  // NOTE: Shen XS only up to 10 GeV/n;
  theIonCascade= new G4BinaryLightIonReaction;
  theIonCascade->SetMinEnergy(80*MeV);
  theIonCascade->SetMaxEnergy(40*GeV);

  // Generic Ion and He3
  // NOTE: Shen XS only up to 10 GeV/n;
  theGenIonCascade = new G4BinaryLightIonReaction;
  theGenIonCascade->SetMinEnergy(0*MeV);
  theGenIonCascade->SetMaxEnergy(30*GeV);

  // Cross sections
  G4TripathiCrossSection* theTripathiCrossSection;
  G4IonsShenCrossSection* theShenCrossSection;
  theTripathiCrossSection = new G4TripathiCrossSection;
  theShenCrossSection = new G4IonsShenCrossSection;


  theParticleIterator->reset();
  while( (*theParticleIterator)() )
  {
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    G4String particleName = particle->GetParticleName();

    if(particleName == "deuteron") 
    {
      pmanager->AddDiscreteProcess(theElasticProcess);

      G4DeuteronInelasticProcess* theDeuteronInelasticProcess;
      theDeuteronInelasticProcess = new G4DeuteronInelasticProcess;   
      
      G4LEDeuteronInelastic* theLEDeuteronInelasticModel;
      theLEDeuteronInelasticModel = new G4LEDeuteronInelastic();
      theLEDeuteronInelasticModel->SetMaxEnergy(100*MeV);

      theDeuteronInelasticProcess->AddDataSet(theTripathiCrossSection);
      theDeuteronInelasticProcess->AddDataSet(theShenCrossSection);
      theDeuteronInelasticProcess->RegisterMe(theLEDeuteronInelasticModel);
      theDeuteronInelasticProcess->RegisterMe(theIonCascade);
      pmanager->AddDiscreteProcess(theDeuteronInelasticProcess);
    }
    else if (particleName == "triton") 
    {
      pmanager->AddDiscreteProcess(theElasticProcess);

      G4TritonInelasticProcess* theTritonInelasticProcess;
      theTritonInelasticProcess = new G4TritonInelasticProcess; 
      
      G4LETritonInelastic* theLETritonInelasticModel;
      theLETritonInelasticModel = new G4LETritonInelastic();
      theLETritonInelasticModel->SetMaxEnergy(100*MeV);

      theTritonInelasticProcess->AddDataSet(theTripathiCrossSection);
      theTritonInelasticProcess->AddDataSet(theShenCrossSection);
      theTritonInelasticProcess->RegisterMe(theLETritonInelasticModel);
      theTritonInelasticProcess->RegisterMe(theIonCascade);
      pmanager->AddDiscreteProcess(theTritonInelasticProcess);
    }
    else if (particleName == "alpha") 
    {
      pmanager->AddDiscreteProcess(theElasticProcess);

      G4AlphaInelasticProcess* theAlphaInelasticProcess;
      theAlphaInelasticProcess = new G4AlphaInelasticProcess;

      G4LEAlphaInelastic* theLEAlphaInelasticModel;
      theLEAlphaInelasticModel = new G4LEAlphaInelastic();
      theLEAlphaInelasticModel->SetMaxEnergy(100*MeV);

      theAlphaInelasticProcess->AddDataSet(theTripathiCrossSection);
      theAlphaInelasticProcess->AddDataSet(theShenCrossSection);
      theAlphaInelasticProcess->RegisterMe(theLEAlphaInelasticModel);
      theAlphaInelasticProcess->RegisterMe(theIonCascade);
      pmanager->AddDiscreteProcess(theAlphaInelasticProcess);
    }
    else if (particleName == "He3")
    {
      pmanager->AddDiscreteProcess(theElasticProcess);

      G4HadronInelasticProcess* theHe3InelasticProcess;
      theHe3InelasticProcess = new G4HadronInelasticProcess("He3Inelastic", G4He3::He3());
      
      theHe3InelasticProcess->AddDataSet(theTripathiCrossSection);
      theHe3InelasticProcess->AddDataSet(theShenCrossSection);
      theHe3InelasticProcess->RegisterMe(theGenIonCascade);
      pmanager->AddDiscreteProcess(theHe3InelasticProcess);
    }

    else if (particleName == "GenericIon")
    {
      pmanager->AddDiscreteProcess(theElasticProcess);

      G4HadronInelasticProcess* theGenericIonInelasticProcess;
      theGenericIonInelasticProcess = new G4HadronInelasticProcess
        ("IonInelastic", G4GenericIon::GenericIon());

      theGenericIonInelasticProcess->AddDataSet(theTripathiCrossSection);
      theGenericIonInelasticProcess->AddDataSet(theShenCrossSection);
      theGenericIonInelasticProcess->RegisterMe(theGenIonCascade);
      pmanager->AddDiscreteProcess(theGenericIonInelasticProcess);
    }
  }
}
#if 0
/////////////////////////////// Optical Process

//#include "G4Cerenkov.hh"
//#include "dywCerenkov.hh"
//#include "dywScintillation.hh"
#include "G4OpAbsorption.hh"
#include "G4OpRayleigh.hh"
#include "G4OpBoundaryProcess.hh"
//#if 0
void LyonPhysicsList::ConstructOp()
{
  theCerenkovProcess           = new G4Cerenkov("Cerenkov");
  //theScintillationProcess      = new dywScintillation("Scintillation");
  theAbsorptionProcess         = new G4OpAbsorption();
  theRayleighScatteringProcess = new G4OpRayleigh();
  theBoundaryProcess           = new G4OpBoundaryProcess();
  
  theCerenkovProcess->SetMaxNumPhotonsPerStep(300);
  theCerenkovProcess->SetTrackSecondariesFirst(true);

  theScintillationProcess->SetScintillationYieldFactor(1.);
  theScintillationProcess->SetTrackSecondariesFirst(true);
  
  SetVerbose(1);
  G4OpticalSurfaceModel themodel = unified;
  theBoundaryProcess->SetModel(themodel);

  theParticleIterator->reset();
  while( (*theParticleIterator)() )
  {
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    G4String particleName = particle->GetParticleName();
    
    if(theCerenkovProcess->IsApplicable(*particle)) 
    {
      pmanager->AddContinuousProcess(theCerenkovProcess);
    }

    if(theScintillationProcess->IsApplicable(*particle)) 
    {
      pmanager->AddProcess(theScintillationProcess);
      pmanager->SetProcessOrderingToLast(theScintillationProcess, idxAtRest);
      pmanager->SetProcessOrderingToLast(theScintillationProcess, idxPostStep);
    }
    if (particleName == "opticalphoton") 
    {
      LOGINFO(dyb) << " AddDiscreteProcess to OpticalPhoton " << G4endl;
      pmanager->AddDiscreteProcess(theAbsorptionProcess);
      pmanager->AddDiscreteProcess(theRayleighScatteringProcess);
      pmanager->AddDiscreteProcess(theBoundaryProcess);
    }
   }
}
//#endif
// Set verbose for optical photon process
void LyonPhysicsList::SetVerbose(G4int verbose)
{
  theCerenkovProcess->SetVerboseLevel(verbose);
  //theScintillationProcess->SetVerboseLevel(verbose);
  theAbsorptionProcess->SetVerboseLevel(verbose);
  theRayleighScatteringProcess->SetVerboseLevel(verbose);
  theBoundaryProcess->SetVerboseLevel(verbose); 
}

//#if 0
void LyonPhysicsList::SetNbOfPhotonsCerenkov(G4int MaxNumber)
{  
  theCerenkovProcess->SetMaxNumPhotonsPerStep(MaxNumber);
}
#endif
void LyonPhysicsList::SetCuts()
{         
  // special for low energy physics
  G4double lowlimit=250*eV;
  G4ProductionCutsTable::GetProductionCutsTable()->SetEnergyRange(lowlimit,100.*GeV);

  // set cut values for gamma at first and for e- second and next for e+,
  // because some processes for e+/e- need cut values for gamma 
  SetCutValue(cutForGamma, "gamma");
  SetCutValue(cutForElectron, "e-");
  SetCutValue(cutForPositron, "e+");
}




